---
title: 函数拓展之：length属性和作用域
date: 2017-04-17 19:58:41
tags: [es6,length,context]
---

## 函数length属性

指定了默认值之后，函数的length属性只返回没有指定默认值的参数个数，也就是 指定默认值之后，length属性失真了。

> lenght属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也是不计入这个length属性的。**如果设置默认值的参数不是尾参数，那么length属性也不再计入后面的参数了**

```javascript

(function(a){}).length //1

(function(a=5){}).length //0

(function(a,b,c=5){}).length //2

(function(...args){}).length //0

(function(a,b=5,c){}).length //1

(function(a=5,b,c){}).length //0

```
<!-- more -->

## 作用域

一旦设置了参数的默认值，函数将进行声明初始化，参数将会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。

```javascript

var x=1;

function f(x,y=x){

    console.log(y);

}

f(2)  //2

```
> 上面代码中，参数 `y`的默认值等于变量`x`。调用函数`f`时，参数形成了一个单独的作用域。在这个作用域里面，默认值变量`x`指向第一个参数`x`,而不是全局变量`x`，因此 输出 2。

---

```javascript

let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1

```
>上面代码中，函数`f`调用时，参数`y=x`形成一个单独的作用域。这个作用域里面，变量`x`本身是没有定义的，所以指向了外面的全局变量`x`。函数调用的时候，函数体内部的局部变量`x`是影响不到默认值变量`x`的。

---

```javascript

//例子1

var x=1;
function foo(x,y=function(){x=2;}){

    var x=3; //重新声明的内部变量，和参数的单独作用域不同

    y();  //y里面的x指向第一个参数x

    console.log(x);
}

foo() // 3
x     // 1

//例子2

var x=1;
function foo(x,y=function(){x=2;}){

    x=3; // 此时指向了第一个参数

    y(); //y里面的x指向第一个参数x

    console.log(x);
}

foo() // 2
x     // 1


```
>- 上面代码中，例子1的函数`foo`的参数形成一个单独作用域。这个作用域里面，首先声明了变量`x`，然后声明了变量`y`，`y`的默认值是一个匿名函数。这个匿名函数内部的变量`x`，指向同一个作用域的第一个参数`x`。
>- 函数`foo`内部又声明了一个`内部变量x`，该变量与`第一个参数x`由于不是同一个作用域，所以不是同一个变量，因此执行`y`后，`内部变量x`和`外部全局变量x`的值都没变。
>- 如果将`var x = 3`的`var`去除，函数`foo`的`内部变量x`就指向`第一个参数x`，与匿名函数内部的`x`是一致的，所以最后输出的就是2，而外层的`全局变量x`依然不受影响。